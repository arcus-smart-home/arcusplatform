/*
 * Copyright 2019 Arcus Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import groovy.transform.Field
capability		DoorLock
description		"Default implementation for the ZWave DoorLock capability"
version			"1.0"

@Field def final String DEFAULT_NAME = 'Unknown Device'
@Field def final String RESERVED = "RESERVED"

@Field def final byte DOOR_LOCKED		= 0xFF
@Field def final byte DOOR_UNLOCKED		= 0x00

@Field def final int SETUP_DELAY_MILLIS			= 30000	//30 seconds after connect ask for the lock state again in case we don't get a response from our original request
@Field def final int BUZZ_IN_TIMEOUT_MILLIS		= 45000	//30 second buzzin timeout + 15 seconds to deliver to end device
@Field def final int GETPIN_DELAY_MILLIS		= 20000	//20 seconds
@Field def final long DFLT_READBACK_DELAY  = 5000	// 5 second delay before reading

@Field def final int LOCKSTATE_DELAY_MILLIS   = 10000


setAttributes('doorlock') {
	String name = vars.'CURRENT_NAME'?:DEFAULT_NAME
	log.debug "${name} driver received set doorlock attribute message"
	
	def attributes = message.attributes
	for(attribute in attributes) {
		switch(attribute.key) {
			case DoorLock.lockstate:
				if (DoorLock.LOCKSTATE_LOCKED == attribute.value ) {
					ZWave.door_lock.operation_set(DOOR_LOCKED)
					updateLockState(this,DoorLock.LOCKSTATE_LOCKING)
				} else if (DoorLock.LOCKSTATE_UNLOCKED == attribute.value ) {
					ZWave.door_lock.operation_set( DOOR_UNLOCKED )
					updateLockState(this,DoorLock.LOCKSTATE_UNLOCKING)
				} else {
					log.warn "${name} Ignoring attempt to set lock to unexpected Lock State:{}", attribute.value
				}
				break
				
			default:
				log.error "${name} Unrecognized attribute: {}", attribute
				break
		}
	}
}
	
/**
 * Authorize the person with the given person Id to unlock the door with his/her pin.
 *
 * Returns the slot number the person has been assigned or 0 if there a no available slots.
 */
onDoorLock.AuthorizePerson {
	String name = vars.'CURRENT_NAME'?:DEFAULT_NAME
	def personId = message.attributes['personId']
	def slots = getDoorLockSlots(this)

	log.debug "${name} - AuthorizePerson: current slots: ${slots}"
   // Check to see if the user has already been assigned a slot on the
   // lock. If they haven't look for a new slot to assign the user into.
	int slot = findSlotForUser(this,name,slots,personId)
	slot = (slot != 0) ? slot : findAndAssignNewSlotToUser(this,name,slots,personId,DoorLock.numPinsSupported.get())
   
   // If we couldn't assign the slot to the user then return an error
   // to the source of the original request.
   if (slot == 0) {
	   emit 'doorlock:PinOperationFailed', ['personId':personId, 'slot':slot, 'message': 'No slot available']
	   sendResponse ('Error', [ code: 'request.unsatisfiable', message: 'No slot available' ])
      return
   }

   // Update the slot mappings and attempt to provision the PIN into
   // the doorlock in the given slot.
   log.info "${name} attempting to provision user ${personId} into slot ${slot}"
   DoorLock.slots slots
   log.debug "${name} - AuthorizePerson: updated slots: ${DoorLock.slots.get()}"

   byte[] pinData = PinManagement.getPin( personId )
	ZWave.user_code.set(slot, 0x01, pinData[0], pinData[1], pinData[2], pinData[3])

	if (true != vars.'DISABLE_GET_AFTER_PINSET') {
	  log.debug "${name} - AuthorizePerson: scheduling GetPinAfterAuthorize"
      vars.'DEFERRED_GETPIN_SLOT' = slot
		Scheduler.scheduleIn 'GetPinAfterAuthorize', GETPIN_DELAY_MILLIS
   }

   sendResponse( 'doorlock:AuthorizePersonResponse', ['slotId':slot] )
}

/**
 * Remove the person with the given person Id ability to unlock the door with their pin.
 */
onDoorLock.DeauthorizePerson {
	String name = vars.'CURRENT_NAME'?:DEFAULT_NAME
	def personId = message.attributes['personId']
	def slots = getDoorLockSlots(this)

	log.debug "${name} - DeauthorizePerson: current slots: ${slots}"
	int slot = findSlotForUser(this,name,slots,personId)
	if (slot == 0) {
	   emit 'doorlock:PinOperationFailed', ['personId':personId, 'slot':slot, 'message': 'No slot assigned to ${personId}']
	   sendResponse ('Error', [ code: 'request.unsatisfiable', message: 'No slot assigned to person ${personId}' ])
	   return;
	}

	// Attempt to deprovision the PIN from the given slot on the door lock.
   log.info "${name} attempting to deprovision user ${personId} from slot ${slot}"
   ZWave.user_code.set(slot, 0x00, 0x00, 0x00, 0x00, 0x00)

	if (true != vars.'DISABLE_GET_AFTER_PINSET') {
	  log.debug "${name} - DeauthorizePerson: scheduling GetPinAfterAuthorize"
      vars.'DEFERRED_GETPIN_SLOT' = slot
		Scheduler.scheduleIn 'GetPinAfterAuthorize', GETPIN_DELAY_MILLIS
   }

	sendResponse('doorlock:DeauthorizePersonResponse', [:])
}

/**
 * Clear all the pins currently set in the lock.
 */
onDoorLock.ClearAllPins {
	String name = vars.'CURRENT_NAME'?:DEFAULT_NAME

   log.warn "${name} attempting to clear all PINs"
   log.debug "${name} - ClearAllPins: current slots: ${DoorLock.slots.get()}"

	DoorLock.slots [:]
   log.debug "${name} - ClearAllPins: updated slots: ${DoorLock.slots.get()}"

	ZWave.user_code.set(0, 0x00, 0x00, 0x00, 0x00, 0x00)
	sendResponse('doorlock:ClearAllPinsResponse', ['unlocked':true])
}

/**
 * Buzz a user in.
 */
onDoorLock.BuzzIn {
	String name = vars.'CURRENT_NAME'?:DEFAULT_NAME

   def state = DoorLock.lockstate.get()
	boolean isLocked = (DoorLock.LOCKSTATE_LOCKED == state) ||
	                   (DoorLock.LOCKSTATE_LOCKING == state) 

	if(isLocked) {
	   log.info "${name} buzzing user in"

		updateLockState(this,DoorLock.LOCKSTATE_UNLOCKING)
      ZWave.door_lock.operation_set(DOOR_UNLOCKED)

		Scheduler.scheduleIn 'LockAfterBuzzIn', BUZZ_IN_TIMEOUT_MILLIS
	}

	sendResponse('doorlock:BuzzInResponse', ['unlocked':isLocked])
}

onEvent('LockAfterBuzzIn') {
	String name = vars.'CURRENT_NAME'?:DEFAULT_NAME
   log.info "${name} locking door after buzz in"

   updateLockState(this,DoorLock.LOCKSTATE_LOCKING)
   ZWave.door_lock.operation_set(DOOR_LOCKED)
}

onEvent('GetPinAfterAuthorize') {
	String name = vars.'CURRENT_NAME'?:DEFAULT_NAME
   log.info "${name} getting PIN after pin operation"
   ZWave.user_code.get(vars.'DEFERRED_GETPIN_SLOT')
}

////////////////////////////////////////////////////////////////////////////////
// Utilities
////////////////////////////////////////////////////////////////////////////////

static def getDoorLockSlots(ctx) {
   def slots = ctx.DoorLock.slots.get()
   if (slots == null) {
      return [:]
   }

   return [:] << slots
}

static def getUserInSlot(ctx,slot) {
   return ctx.DoorLock.slots.get()[slot.toString()]
}

static void updateLockState(ctx,newState) {
	def prevState = ctx.DoorLock.lockstate.get()
	ctx.DoorLock.lockstate newState

	if (newState != prevState) {
		ctx.DoorLock.lockstatechanged new Date()
	}
}

////////////////////////////////////////////////////////////////////////////////
// Z-Wave Door Lock Operation Report
////////////////////////////////////////////////////////////////////////////////

static void handleLockOperationReport(ctx,name,message) {
	def mode = message.command.get('doorlockmode') & 0xFF;
	ctx.log.debug "${name} driver received an operation report: ${mode} -- ${message}"

	switch (mode) {
	case 0x00: // door unsecured
	   updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
	   break;

	case 0x01: // door unsecured with timeout
	   updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
	   break;

	case 0x10: // door unsecured for inside door handle
	   updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
	   break;

	case 0x11: // door unsecured for inside door handle with timeout
	   updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
	   break;

	case 0x20: // door unsecured for outside door handle
	   updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
	   break;

	case 0x21: // door unsecured for outside door handle with timeout
	   updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
	   break;

   case 0xFE: // door in unknown state
	   ctx.log.warn "${name} driver reported unknown state: ${mode}"
	   break;

	case 0xFF:
	   updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
	   break;

	default:
	   ctx.log.warn "${name} driver reported unrecognized state: ${mode}"
	   break;
	}
}

////////////////////////////////////////////////////////////////////////////////
// Z-Wave Battery Level Report
////////////////////////////////////////////////////////////////////////////////

static void handleBatteryLevelReport(ctx,name,message) {
   def batteryLevel = message.command.get('level')
   if (batteryLevel == null) {
   	  ctx.log.warn "${name} battery level null"
      return
   }

	int bl = batteryLevel & 0xFF
	if(0xFF == bl) {
		ctx.log.warn "${name} battery level is low"
		ctx.DevicePower.battery 0
	} else {
		ctx.DevicePower.battery bl
		ctx.log.debug "${name} battery level [${bl}]"
	}
}

////////////////////////////////////////////////////////////////////////////////
// Z-Wave User Code Report
////////////////////////////////////////////////////////////////////////////////
   
static void handleUserCodeReport(ctx,name,message) { 
	def slots = getDoorLockSlots(ctx)
	def userId = message.command.get('useridentifier')
	def status = message.command.get('useridstatus')

   if (status == null || userId == null || slots == null) {
      ctx.log.warn "${name} received bad status report: slot=${userId}, status=${status}"
      return
   }
	ctx.log.debug "${name} driver received an user code report: slot=${userId}, status=${status} -- message=${message}, slots=${slots}"

	switch (status & 0xFF) {
	case 0:
	   handleUserSlotAvailable(ctx,name,slots,userId)
	   break
	case 1:
      handleUserSlotOccupied(ctx,name,slots,userId)
	   break
	case 2:
      // For Schlage, this indicates a PIN matches the first 4 digits of the programming code
      handleUserSlotReserved(ctx,name,slots,userId)
	   break
	case 0xFE:
      // For Schlage, this indicates a duplicate PIN
      handleUserSlotNotAvailable(ctx,name,slots,userId)
	   break
	default:
      ctx.log.warn "${name} received unknown status report: slot=${userId}, status=${status}"
	   break
	}
}

static int findSlotForUser(ctx,name,slots,personId) {
	for (def s : slots.keySet()) {
		if (personId == slots[s]) {
		    ctx.log.debug "${name} - findSlotForUser: slot: ${s}, person: ${personId}"
			return s.toInteger()
		}
	}

	return 0
}

static int findAndAssignNewSlotToUser(ctx,name,slots,personId,maxPinSupported) {
	for (def pc in 1..maxPinSupported) {
	   def key = pc.toString()
		if (!slots.containsKey(key)) {
		   slots.put(key,personId)
		   ctx.log.debug "${name} - findAndAssignNewSlotToUser: slot: ${pc}, person: ${personId}"
		   return pc
      }
	}

	return 0
}

static void handleUserSlotAvailable(ctx,name,slots,userId) {
	if (userId == 0) {
		//The reason we need to do this is not to clear slots when the device is first added as the slots should be empty.  
		//This is to avoid the issue report for clearing all the pins came in after the first automatic AuthorizePerson request's report.
		if (ctx.vars.'CLEAR_PINS_ON_ADD' == null) {
			ctx.log.warn "${name} has deprovisioned all user PINS"
	      ctx.DoorLock.slots [:]
		}else {
			ctx.vars.'CLEAR_PINS_ON_ADD' = null
		}

      doPinsCleared(ctx,name)
		return
	}

   def personId = slots.remove(userId.toString())
   if (personId != null) {
	   ctx.log.warn "${name} received report that ${personId} was deprovisioned from slot ${userId}"		

	   ctx.DoorLock.slots slots
	   ctx.log.debug "${name} - handleUserSlotAvailable - current slots: ${slots}"

      ctx.emit 'doorlock:PersonDeauthorized', ['personId':personId, 'slot':userId]
	} else {
	   ctx.log.warn "${name} person was not found in slots - ${userId}"
	}
}

static void handleUserSlotOccupied(ctx,name,slots,userId) {
   if (userId == 0) {
      return
   }

	def personId = slots.get(userId.toString())
	ctx.log.debug "${name}  - handleUserSlotOccupied - current slots: ${slots}"
	if(personId == null) {
		ctx.log.warn "${name} handleUserSlotOccupied - unknown user ${userId} added at lock"
	   doPinAddedAtLock(ctx,name,userId)
		return
	}

   ctx.log.info "${name} received report that ${personId} was provisioned into slot ${userId}"		
   ctx.emit 'doorlock:PersonAuthorized', ['personId':personId, 'slot':userId]
}

static void handleUserSlotReserved(ctx,name,slots,userId) {
   handleUserSlotFailure(ctx,name,slots,userId, "slot reserved")
}

static void handleUserSlotNotAvailable(ctx,name,slots,userId) {
   handleUserSlotFailure(ctx,name,slots,userId, "slot state not available")
}

static void handleUserSlotFailure(ctx,name,slots,userId,msg) {
   if (userId == 0) {
      return
   }

	def personId = slots.remove(userId.toString())
	if (personId != null) {
	   ctx.log.warn "${name} received report that ${personId} failed in slot ${userId}: ${msg}"		

	   ctx.DoorLock.slots slots
	   ctx.emit 'doorlock:PinOperationFailed', ['personId':personId, 'slot':userId, 'message': "${msg}"]
	}
}

////////////////////////////////////////////////////////////////////////////////
// Z-Wave Alarm Report
////////////////////////////////////////////////////////////////////////////////
 
static void handleSchlageAlarmReportViaNotification(ctx,name,message) {
    def handled = false;
	def alarmType = message.command.get('alarmtype') & 0xFF
	def alarmLevel = message.command.get('alarmlevel') & 0xFF
	def notificationStatus = message.command.get('notificationStatus')
	def notificationType = message.command.get('notificationType')
	def event = message.command.get('event')
	ctx.log.debug "${name} driver received an alarm report "+ 
		"type [${alarmType}], " +
		"level [${alarmLevel}], " +
		"notificationStatus:[${notificationStatus}], " + 
		"notificationType:[${notificationType}], "+
		"event:[${event}], " +
		"message:[${message}]";
	
	switch( notificationType ) {
		case 0x06:
			switch(event) {
				case 0x01: // Locked from inside or outside by key
					updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
					break;
				case 0x02: // Unlocked from inside or outside by key
					updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
					break; 
				case 0x05: // Locked from outside
					updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
					doPinUsed(ctx, name, message.command.get('parameter1'), "locked") // How do tell who the person is by pressing on the schlage button to lock?
					break;
				case 0x06: // Unlocked from outside
					updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
					doPinUsed(ctx, name, message.command.get('parameter1'), "unlocked")
					break;
				case 0x09: // Auto Relocked                   TODO:Include it was autorelocked in history logs
					updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
					break;
				case 0x10:
	            doPinInvalid(ctx, name, 0, "exceeded PIN entry limit")
					break;
				case 0x0B:
					ctx.log.debug "${name} jammed"
					break;
				default:
					ctx.log.error"${name} received unhandled alarm report event:[${event}] "
					break;
			    }
			handled = true // all Case 06 notifications  either handled or logged as unhandled.
			break;
		default:
			ctx.log.error"${name} received unhandled alarm report notification type:[${notificationType}] "
			break;
	}
		
	switch(alarmType) {	
	case 0xA1:
		if(alarmLevel != 1) {
			ctx.log.debug "${name} Tamper Alarm, but unknown alert level ${alarmLevel}"
			handled = true;
		}
	   break;

	default:
	   if ( handled == false) {
	   ctx.log.error"${name} received unhandled alarm report alarm type:[${alarmType}] + level [${alarmLevel}] \
	     + notificationStatus:[${notificationStatus}] + notificationType:[${notificationType}] + event:[${event}] "
}
	   break;
	}
}

static void handleSchlageAlarmReportViaType(ctx,name,message) {
    def final int LOCKSTATE_DELAY_MILLIS   = 10000
	def alarmType = message.command.get('alarmtype') & 0xFF
	def alarmLevel = message.command.get('alarmlevel') & 0xFF

	ctx.log.debug "${name} driver received an alarm report type [${alarmType}] level [${alarmLevel}] message [${message}]"
	switch(alarmType) {
	case 0x10:
	   updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
		doPinUsed(ctx, name, alarmLevel, "locked")
		ctx.Scheduler.scheduleIn 'DeferredLockStateRead', LOCKSTATE_DELAY_MILLIS
		break;

	case 0x30:
		if (alarmLevel == 0xFF) {
			ctx.log.debug "${name} Lock was reset manually to factory default."
		} else {
			ctx.log.debug "${name} Lock was reset to factory default, invalid level [${alarmLevel}]"
		}
		break;

	case 0x60:
		if (alarmLevel == 0xFF) {
			ctx.log.debug "${name} Lock keypad temporarily disabled."
		} else {
			ctx.log.debug "${name} Lock keypad temporarily disabled, invalid level [${alarmLevel}]"
		}
		break;

	case 0x70:
		if (alarmLevel == 0xFF) {
			ctx.log.debug "${name} Lock new master code added."
		} else {
			ctx.log.debug "${name} Lock new master code added, invalid level [${alarmLevel}]"
		}
		break;

	case 0x80:
		if (alarmLevel == 0xFF) {
			ctx.log.debug "${name} Lock keypad power up."
		} else {
			ctx.log.debug "${name} Lock keypad power up, invalid level [${alarmLevel}]"
		}
		break;

	case 0x90:
		if (alarmLevel == 0) {
			ctx.log.debug "${name} Lock is busy, cleared."
		} else if (alarmLevel == 0xFF) {
			ctx.log.debug "${name} Lock is busy, set."
		} else {
			ctx.log.debug "${name} Lock is busy, invalid level [${alarmLevel}]"
		}
		break;

   default:
	ctx.log.error "${name} driver received an unhandled alarm report type [${alarmType}] level [${alarmLevel}]"
		break;
	}
}

onEvent('DeferredLockStateRead') {
	log.debug "GenericZWaveDoorLock received DeferredLockStateRead event"
	ZWave.door_lock.operation_get()
}

static void handleYaleAlarmReport(ctx,name,message) {
	def alarmType = message.command.get( 'alarmtype' ) & 0xFF
	def alarmLevel = message.command.get( 'alarmlevel' ) & 0xFF
	def slots = [:]

   ctx.log.debug "${name} received an alarm report type: ${alarmType} - level: ${alarmLevel} - message: ${message}"
	switch( alarmType ) {
		case 0x12:
			updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
			doPinUsed(ctx, name, alarmLevel, "locked")
			break;
		case 0x15:
		case 0x1B:		
		case 0x18:
			updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
			break;					
		case 0x13:
			updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
			doPinUsed(ctx, name, alarmLevel, "unlocked")
			break;
		case 0x16:
		case 0x19:
			updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
			break;
		case 0x70:
		 // Alarm 0 = master slot, will be ignored
			slots = getDoorLockSlots(ctx)
			ctx.log.debug "${name} - alarm report calling handleUserSlotOccupied: slots: ${slots}"
            handleUserSlotOccupied(ctx,name,slots,alarmLevel)
			break;
		case 0xA1:
			if(alarmLevel == 1) {
	         doPinInvalid(ctx, name, 0, "exceeded PIN entry limit")
			} else if(alarmLevel == 2) {
			   ctx.log.debug "${name} Front escutcheon removed from main"
			} else {
			   ctx.log.debug "${name} Tamper Alarm, but unknown alert level ${alarmLevel}"
			}
			break;
		case 0xA7: 
			ctx.DevicePower.battery 25
			break;
		case 0xA8:
			ctx.DevicePower.battery 10
			break;
		case 0xA9:
			ctx.DevicePower.battery 0
			break;
		case 0x09:
		   ctx.log.debug "${name} deadbolt motor jammed"
			break;
		case 0x71:
			slots = getDoorLockSlots(ctx)
			ctx.log.debug "${name} - alarm report calling handleUserSlotFailure: slots: ${slots}"
            handleUserSlotFailure(ctx,name,slots,alarmLevel,"duplicate PIN code")
		    break;
		case 0x82:
		   ctx.log.debug "${name} RF Module Power Cycled"
			break;
		case 0x21:
		   if (alarmLevel == 0xFF) {
	         ctx.DoorLock.slots [:]
            doPinsCleared(ctx,name)
		   } else {
			slots = getDoorLockSlots(ctx)
			ctx.log.debug "${name} - alarm report calling handleUserSlotAvailable: slots: ${slots}"
            handleUserSlotAvailable(ctx,name,slots,alarmLevel)
		   }
			break;
		case 0x81:
		   ctx.log.debug "${name} Lock Handing Completed"
			break;
		case 0x26:
	      doPinInvalid(ctx, name, alarmLevel, "non-access code entered")
			break;
		case 0x30:
			if(alarmLevel == 1) {
			   ctx.log.debug "${name} Lock was reset manually to factory default."
			} else if(alarmLevel == 2) {
			   ctx.log.debug "${name} Lock was reset to factory default over RF."
			} else {
			   ctx.log.debug "${name} Lock Reset To Factory Default, but unknown alarm level ${alarmLevel}"
			}

	      ctx.DoorLock.slots [:]
         doPinsCleared(ctx,name)
			break;
		default:
   			ctx.log.error "${name} received an unhandled alarm report type: ${alarmType} - level: ${alarmLevel}" 
			break;
	}  
}

static void handleSbdAlarmReport(ctx,name,message) {
	def alarmType = message.command.get( 'alarmtype' )
	def alarmLevel = message.command.get( 'alarmlevel' ) & 0xFF
	def slots = [:]

	ctx.log.debug "${name} received an alarm report type: ${alarmType} - level:  ${alarmLevel} - message: ${message}"
	switch( alarmType ) {
	case 0x12:
		updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
		doPinUsed(ctx, name, alarmLevel, "locked")
		break;
	case 0x15:
	case 0x1B:
	case 0x18:
		updateLockState(ctx,ctx.DoorLock.LOCKSTATE_LOCKED)
		break;
	case 0x13:
		updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
		doPinUsed(ctx, name, alarmLevel, "unlocked")
		break;
	case 0x16:
	case 0x19:
	case 0x1A:
	case 0x11:
	case 0x17:
		updateLockState(ctx,ctx.DoorLock.LOCKSTATE_UNLOCKED)
		break;
	case 0x70:
	   slots = getDoorLockSlots(ctx)
	   ctx.log.debug "${name} - alarm report calling handleUserSlotOccupied: slots: ${slots}"
       handleUserSlotOccupied(ctx,name,slots,alarmLevel)
	   break;
	case 0x20:
		// This doesn't match the SBD spec, but is correct.  The 0x21 event means a single pin was cleared
		ctx.DoorLock.slots [:]
		doPinsCleared(ctx,name)
		break;
	case 0x21:
		// A single pin slot is available - described as event 0x20 in their spec
		slots = getDoorLockSlots(ctx)
	    ctx.log.debug "${name} - alarm report calling handleUserSlotAvailable: slots: ${slots}"
		handleUserSlotAvailable(ctx,name,slots,alarmLevel)
		break;
	case 0xA1:
	case -95:
	   doPinInvalid(ctx, name, 0, "three failed attempts")
	   break;
	case 0xA2:
	case -94:
	   doPinInvalid(ctx, name, alarmLevel, "invalid time")
	   break;
	case 0xA7:
	case -89:
		ctx.DevicePower.battery 15
	   break;
	case 0xA8:
	case -88:
		ctx.DevicePower.battery 5
	   break;
	case 0xA9:
	case -87:
		ctx.DevicePower.battery 1
	   break;
   default:
       ctx.log.warn "${name} received an unhandled alarm report type: ${alarmType} - level: ${alarmLevel}"
		break;
	}
}
   
static void doPinUsed(ctx,name,slot,action) {
   if (slot < 0) {
      return
   }

   def personId = getUserInSlot(ctx,slot)
	ctx.log.debug "${name} was ${action} by ${personId?:'Unknown Person'}"
	
	if( (null != personId) && ('RESERVED' != personId) ) {
		ctx.PinManagement.setActor(personId)
	}

	ctx.emit 'doorlock:PinUsed', [:]
}
   
static void doPinInvalid(ctx,name,slot,msg) {
   if (slot < 0) {
      return
   }

   def personId = getUserInSlot(ctx,slot)
	ctx.log.debug "${name} reported invalid pin used by ${personId?:'Unknown Person'}: ${msg}"
	
	if( (null != personId) && ('RESERVED' != personId) ) {
		ctx.PinManagement.setActor(personId)
	}

	ctx.emit 'doorlock:InvalidPin', [:]
}

static void doPinAddedAtLock(ctx,name,slot) {
   if (slot <= 0) {
      return
   }

   ctx.log.warn "${name} attempting to remove PIN from slot ${slot} because PIN was added manually at door"
   ctx.ZWave.user_code.set(slot, 0x00, 0x00, 0x00, 0x00, 0x00)

   def personId = getUserInSlot(ctx,slot)
	if( (null != personId) && ('RESERVED' != personId) ) {
		ctx.PinManagement.setActor(personId)
	}

   ctx.emit 'doorlock:PinAddedAtLock', [:]
}

static void doPinRemovedAtLock(ctx,name,slot) {
   if (slot <= 0) {
      return
   }

   def slots = getDoorLockSlots(ctx)
	def personId = slots.remove(slot.toString())
	if( (null != personId) && ('RESERVED' != personId) ) {
      ctx.log.warn "${name} removed user ${personId} from slot ${slot} because PIN was removed manually at door"
      ctx.DoorLock.slots slots
      
		ctx.PinManagement.setActor(personId)
      ctx.emit 'doorlock:PersonDeauthorized', ['personId':personId, 'slot':slot]
   }

   ctx.emit 'doorlock:PinRemovedAtLock', [:]
}

static void doPinsCleared(ctx,name) {
   ctx.log.warn "${name} cleared all pins"
   ctx.emit 'doorlock:AllPinsCleared', [:]
}

